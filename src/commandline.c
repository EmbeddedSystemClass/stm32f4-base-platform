/*
 * commandline.c
 *
 *  Created on: Mar 23, 2013
 *      Author: franz
 */

#include <commandline.h>
#include <stm32_configuration.h>
#include <stm32_serial_functions.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <queue.h>

static const int8_t * const pcEndOfCommandOutputString = ( int8_t * ) "\r\n[Press ENTER to execute the previous command again]\r\n>";


void prvUARTCommandConsoleTask( void *pvParameters )
{
	xQueueHandle *usartQueue = (xQueueHandle)pvParameters;
	int8_t cRxedChar, cInputIndex = 0, *pcOutputString;
	static int8_t cInputString[ cmdMAX_INPUT_SIZE ], cLastInputString[ cmdMAX_INPUT_SIZE ];
	portBASE_TYPE xReturned;

	( void ) pvParameters;

	/* Obtain the address of the output buffer.  Note there is no mutual
	exclusion on this buffer as it is assumed only one command console
	interface will be used at any one time. */
	pcOutputString = FreeRTOS_CLIGetOutputBuffer();

	/* Enable Interrupt for USART RX. COMMANDLINE_USART MUST NOT be used by another function or task!!!*/
	USART_ITConfig(COMMANDLINE_USART, USART_IT_RXNE, ENABLE);

	USART_sendSuspend(COMMANDLINE_USART, " FreeRTOS command server.\r\nType Help to view a list of registered commands.\r\n\r\n>", NULL);

	for( ;; )
	{
		for( ;; )
		{
			vTaskSuspend( NULL );
			if(xQueueReceive( usartQueue, &( cRxedChar ), ( portTickType ) 10 ) )
			{
				break;
			}
		}

		/*Echo the character back*/
		sprintf((char*)pcOutputString, "%c", (char)cRxedChar);
		USART_sendSuspend(COMMANDLINE_USART, (char*)pcOutputString, NULL);

		if( cRxedChar == '\n' || cRxedChar == '\r')
		{
			/* The input command string is complete.  Ensure the previous
			UART transmission has finished before sending any more data.
			This task will be held in the Blocked state while the Tx completes,
			if it has not already done so, so no CPU time will be wasted by
			polling. */
			USART_sendSuspend(COMMANDLINE_USART, "\r\n", NULL);

			/* See if the command is empty, indicating that the last command is
			to be executed again. */
			if( cInputIndex == 0 )
			{
				strcpy( ( char * ) cInputString, ( char * ) cLastInputString );
			}

			/* Pass the received command to the command interpreter.  The
			command interpreter is called repeatedly until it returns
			pdFALSE as it might generate more than one string. */
			do
			{
				/* Get the string to write to the UART from the command
				interpreter. */
				xReturned = FreeRTOS_CLIProcessCommand( cInputString, pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );

				/* Write the generated string to the UART. */
				USART_sendSuspend(COMMANDLINE_USART, (char*)pcOutputString, NULL);

			} while( xReturned != pdFALSE );

			/* All the strings generated by the input command have been sent.
			Clear the input	string ready to receive the next command.  Remember
			the command that was just processed first in case it is to be
			processed again. */
			strcpy( ( char * ) cLastInputString, ( char * ) cInputString );
			cInputIndex = 0;
			memset( cInputString, 0x00, cmdMAX_INPUT_SIZE );

			USART_sendSuspend(COMMANDLINE_USART, (char*)pcEndOfCommandOutputString, NULL);
		}
		else
		{
			if( cRxedChar == '\b' )
			{
				/* Backspace was pressed.  Erase the last character in the
				string - if any. */
				if( cInputIndex > 0 )
				{
					cInputIndex--;
					cInputString[ cInputIndex ] = '\0';
				}
			}
			else
			{
				/* A character was entered.  Add it to the string
				entered so far.  When a \n is entered the complete
				string will be passed to the command interpreter. */
				if( ( cRxedChar >= ' ' ) && ( cRxedChar <= '~' ) )
				{
					if( cInputIndex < cmdMAX_INPUT_SIZE )
					{
						cInputString[ cInputIndex ] = cRxedChar;
						cInputIndex++;
					}
				}
			}
		}
	}
}



